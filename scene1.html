<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: black;
  }
  #canvas {
    width: 100vw;
    height: 100vh;
    outline: none;
    display: block;
  }
  #controls {
    position: fixed;
    top: 12px;
    left: 12px;
    z-index: 10;
  }
  #controls button {
    padding: 6px 10px;
    margin-right: 6px;
    font-size: 14px;
    cursor: pointer;
  }
</style>
<body>
<div id="controls">
  <button id="btnReset">Back</button>
  <button id="btnSpin">Stop rotation</button>
  <button id="btnStrip">Next step</button>
  <button id="btnBox1">Box 1</button>
  <button id="btnBox2">Box 2</button>
  <button id="btnBox3">Box 3</button>
</div>
<canvas id="canvas" width="1200" height="900"></canvas>
<script src="webgl.js"></script>
<script>
// 仅实现：点击胶卷盒后显示暗盒（简化版）
window.addEventListener('load', () => {
  const canvas = document.getElementById('canvas');
  // 让 canvas 可聚焦以接收键盘事件
  canvas.tabIndex = 1;
  canvas.focus();
  const btnReset = document.getElementById('btnReset');
  const btnSpin = document.getElementById('btnSpin');
  const btnStrip = document.getElementById('btnStrip');
  const btnBox1 = document.getElementById('btnBox1');
  const btnBox2 = document.getElementById('btnBox2');
  const btnBox3 = document.getElementById('btnBox3');
  // 适配窗口缩放：调整 canvas 像素尺寸以避免模糊
  const resizeCanvas = () => {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = canvas.clientWidth * dpr;
    canvas.height = canvas.clientHeight * dpr;
    if (canvas.gl) {
      canvas.gl.viewport(0, 0, canvas.width, canvas.height);
    }
  };
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Fallback：若 webgl.js 未暴露 Matrix 等，提供最小实现
  if (typeof Matrix === 'undefined') {
    const c = t => Math.cos(t), s = t => Math.sin(t);
    const identity = () => [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
    const move = (x,y,z) => { if (y===undefined){z=x[2];y=x[1];x=x[0];} return [1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]; }
    const turnX = t => [1,0,0,0, 0,c(t),s(t),0, 0,-s(t),c(t),0, 0,0,0,1];
    const turnY = t => [c(t),0,-s(t),0, 0,1,0,0, s(t),0,c(t),0, 0,0,0,1];
    const turnZ = t => [c(t),s(t),0,0, -s(t),c(t),0,0, 0,0,1,0, 0,0,0,1];
    const scale = (x,y,z) => [x,0,0,0, 0,y??x,0,0, 0,0,z??x,0, 0,0,0,1];
    const mxm = (a,b) => { const m=[]; for(let c=0;c<16;c+=4) for(let r=0;r<4;r++) m.push(a[r]*b[c]+a[r+4]*b[c+1]+a[r+8]*b[c+2]+a[r+12]*b[c+3]); return m; };
    const inverse = src => {
      const dst=[], cofactor=(c,r)=>{let f=(i,j)=>src[c+i&3|(r+j&3)<<2];
        return (c+r&1?-1:1)*((f(1,1)*(f(2,2)*f(3,3)-f(3,2)*f(2,3)))-(f(2,1)*(f(1,2)*f(3,3)-f(3,2)*f(1,3)))+(f(3,1)*(f(1,2)*f(2,3)-f(2,2)*f(1,3))));
      };
      let det=0; for(let n=0;n<16;n++) dst.push(cofactor(n>>2,n&3));
      for(let n=0;n<4;n++) det+=src[n]*dst[n<<2];
      for(let n=0;n<16;n++) dst[n]/=det;
      return dst;
    };
    const perspective = (x,y,z) => [1,0,0,x, 0,1,0,y??x, 0,0,1,z??x, 0,0,0,1];
    const transpose = m => [m[0],m[4],m[8],m[12], m[1],m[5],m[9],m[13], m[2],m[6],m[10],m[14], m[3],m[7],m[11],m[15]];
    window.mxm=mxm; window.perspective=perspective; window.inverse=inverse; window.transpose=transpose;
    window.turnX=turnX; window.turnY=turnY; window.turnZ=turnZ; window.move=move; window.scale=scale;
    window.Matrix = function() {
      let m=[identity()], top=0;
      this.get=()=>m[top];
      this.identity=()=>{m[top]=identity(); return this;}
      this.move=(x,y,z)=>{m[top]=mxm(m[top],move(x,y,z)); return this;}
      this.perspective=(x,y,z)=>{m[top]=mxm(m[top],perspective(x,y,z)); return this;}
      this.pop=()=>{if(top>0) top--; return this;}
      this.push=()=>{m[top+1]=m[top].slice(); top++; return this;}
      this.scale=(x,y,z)=>{m[top]=mxm(m[top],scale(x,y,z)); return this;}
      this.turnX=a=>{m[top]=mxm(m[top],turnX(a)); return this;}
      this.turnY=a=>{m[top]=mxm(m[top],turnY(a)); return this;}
      this.turnZ=a=>{m[top]=mxm(m[top],turnZ(a)); return this;}
    }
  }

  // vertexMap 兜底：若缺失则注入
  if (typeof vertexMap === 'undefined') {
    window.vertexMap = map => {
      let stride=0; for(let i=0;i<map.length;i+=2) stride+=map[i+1];
      let offset=0;
      for(let i=0;i<map.length;i+=2){
        const name=map[i], size=map[i+1];
        const attr=gl.getAttribLocation(gl.program,name);
        gl.enableVertexAttribArray(attr);
        gl.vertexAttribPointer(attr,size,gl.FLOAT,false,stride*4,offset*4);
        offset+=size;
      }
      vertexSize=stride;
    };
  }

  // addTexture 兜底（统一使用纹理单元0，按索引存储纹理对象）
  if (typeof addTexture === 'undefined') {
    if (typeof textures === 'undefined') window.textures = {};
    window.addTexture = (index, src) => {
      const image = new Image();
      image.crossOrigin = 'anonymous';
      image.onload = () => {
        try {
          const tex = gl.createTexture();
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, tex);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
          gl.generateMipmap(gl.TEXTURE_2D);
          textures[index] = tex;
        } catch (e) { console.error('Fallback addTexture error:', e); }
      };
      image.onerror = () => console.error('Failed to load texture', src);
      image.src = src.includes('/') ? src : ('textures/' + src);
    };
  }

  // 拖拽偏移：鼠标拖动，作用于当前选中的盒子
  let dragging = false, lastX = 0, lastY = 0, dragMode = 'move';
  let activeBox = 0;
  const boxPos = [
    { pos:[-1.2, -0.2, 0], offset:[0,0,0], rot:[0,0] },
    { pos:[ 0.0, -0.2, 0], offset:[0,0,0], rot:[0,0] },
    { pos:[ 1.2, -0.2, 0], offset:[0,0,0], rot:[0,0] },
  ];
  let autoSpin = true;
  let spinAngle = 0;
  let lastTick = performance.now();
  let target = 0, filmTarget = 0; // 盒/暗盒状态，底片状态
  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('mousedown', e => {
    dragging = true;
    dragMode = (e.button === 2 || e.shiftKey) ? 'rotate' : 'move';
    const rect = canvas.getBoundingClientRect();
    lastX = e.clientX - rect.left;
    lastY = e.clientY - rect.top;
  });
  canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const dx = x - lastX, dy = y - lastY;
    if (dragMode === 'move') {
      const scale = 0.003; // 平移灵敏度
      boxPos[activeBox].offset[0] += dx * scale;
      boxPos[activeBox].offset[1] -= dy * scale;
    } else {
      const rScale = 0.003; // 旋转灵敏度
      boxPos[activeBox].rot[1] += dx * rScale;       // yaw
      boxPos[activeBox].rot[0] += dy * rScale;       // pitch
      boxPos[activeBox].rot[0] = Math.max(-1.55, Math.min(1.55, boxPos[activeBox].rot[0])); // 放宽仰俯角到约±89°
    }
    lastX = x; lastY = y;
  });
  canvas.addEventListener('mouseup', () => dragging = false);
  canvas.addEventListener('mouseleave', () => dragging = false);

  // 键盘：S 切换自转；B 强制回到胶卷盒并收回底片
  const handleKey = e => {
    const k = e.key.toLowerCase();
    if (k === 's') autoSpin = !autoSpin;
    if (k === 'b') { target = 0; filmTarget = 0; }
    if (k === '1') activeBox = 0;
    if (k === '2') activeBox = 1;
    if (k === '3') activeBox = 2;
  };
  document.addEventListener('keydown', handleKey);
  window.addEventListener('keydown', handleKey);
  canvas.addEventListener('mousedown', () => canvas.focus());
  btnReset.addEventListener('click', () => { target = 0; filmTarget = 0; });
  btnSpin.addEventListener('click', () => { autoSpin = !autoSpin; btnSpin.textContent = autoSpin ? 'Stop rotation' : 'Resume rotation'; });
  const selectBox = idx => { activeBox = idx; target = 0; filmTarget = 0; };
  btnBox1.addEventListener('click', () => selectBox(0));
  btnBox2.addEventListener('click', () => selectBox(1));
  btnBox3.addEventListener('click', () => selectBox(2));
  // Next step：盒 -> 暗盒 -> 暗盒+底片 -> 盒
  btnStrip.addEventListener('click', () => {
    if (target < 0.5) {          // 盒 -> 暗盒
      target = 1;
      filmTarget = 0;
      return;
    }
    if (filmTarget < 0.5) {      // 暗盒 -> 暗盒+底片
      filmTarget = 1;
      return;
    }
    // 暗盒+底片 -> 盒
    target = 0;
    filmTarget = 0;
  });

  function Scene() {
    this.vertexShader = `#version 300 es
      uniform mat4 uMF, uMI;
      in vec3 aPos, aNor;
      in vec2 aUV;
      out vec3 vPos, vNor;
      out vec2 vUV;
      void main() {
        vec4 pos = uMF * vec4(aPos, 1.);
        vec4 nor = vec4(aNor, 0.) * uMI;
        gl_Position = pos * vec4(1.,1.,-.1,1.);
        vPos = pos.xyz;
        vNor = nor.xyz;
        vUV  = aUV;
      }
    `;

    this.fragmentShader = `#version 300 es
      precision highp float;
      uniform vec3 uColor;
      uniform sampler2D uSampler;
      uniform int uUseTexture;
      in vec3 vPos, vNor;
      in vec2 vUV;
      out vec4 fragColor;
      void main() {
        vec3 nor = normalize(vNor);
        float c = .12 + max(0., dot(vec3(.6,.6,.2), nor))
                       + max(0., dot(vec3(-.5,.4,-.2), nor));
        vec3 base = uColor;
        if (uUseTexture == 1) {
          vec4 T = texture(uSampler, vUV);
          base *= T.rgb;
        }
        fragColor = vec4(sqrt(c) * base, 1.);
      }
    `;

    // 纸盒（六面体）——直接复用 hw10 贴图，目标实尺寸比 6*4*4，以 scale 设置
    const face = (...v) => ({ triangle_strip: false, data: new Float32Array(v) });
    const cubeFaces = {
      front: face(-1,-1,-1,0,0,-1,0,1,  1,-1,-1,0,0,-1,0,0,  1,1,-1,0,0,-1,1,0,  1,1,-1,0,0,-1,1,0, -1,1,-1,0,0,-1,1,1, -1,-1,-1,0,0,-1,0,1),
      back : face(-1,-1, 1,0,0,1,1,0,   1,-1,1,0,0,1,0,0,    1,1,1,0,0,1,0,1,    1,1,1,0,0,1,0,1,   -1,1,1,0,0,1,1,1,  -1,-1,1,0,0,1,1,0),
      left : face(-1,-1,-1,-1,0,0,1,0, -1,1,-1,-1,0,0,1,1, -1,1,1,-1,0,0,0,1,  -1,1,1,-1,0,0,0,1, -1,-1,1,-1,0,0,0,0, -1,-1,-1,-1,0,0,1,0),
      right: face( 1,-1,-1,1,0,0,0,0,   1,1,-1,1,0,0,0,1,   1,1,1,1,0,0,1,1,    1,1,1,1,0,0,1,1,    1,-1,1,1,0,0,1,0,   1,-1,-1,1,0,0,0,0),
      top  : face(-1,1,-1,0,1,0,0,1,    1,1,-1,0,1,0,0,0,   1,1,1,0,1,0,1,0,    1,1,1,0,1,0,1,0,   -1,1,1,0,1,0,1,1,  -1,1,-1,0,1,0,0,1),
      bottom:face(-1,-1,-1,0,-1,0,1,1,  1,-1,-1,0,-1,0,1,0, 1,-1,1,0,-1,0,0,0,  1,-1,1,0,-1,0,0,0, -1,-1,1,0,-1,0,0,1, -1,-1,-1,0,-1,0,1,1),
    };

    // 三个胶卷盒的六面贴图（可自行替换）
    const boxTexturesA = [
      'textures/1.png',
      'textures/3.png',
      'textures/4.png',
      'textures/2.png',
      'textures/5.png',
      'textures/5.png',
    ];
    const boxTexturesB = [
      'textures/1.png',
      'textures/3.png',
      'textures/4.png',
      'textures/2.png',
      'textures/5.png',
      'textures/5.png',
    ];
    const boxTexturesC = [
      'textures/1.png',
      'textures/3.png',
      'textures/4.png',
      'textures/2.png',
      'textures/5.png',
      'textures/5.png',
    ];
    // 暗盒（金属罐体），简单侧面+盖子
    const parametric = (f, nu, nv) => {
      const V = [];
      for (let j = 0; j < nv; j++) {
        for (let i = 0; i <= nu; i++) {
          V.push(f(i/nu, j/nv));
          V.push(f(i/nu, (j+1)/nv));
        }
        V.push(f(1, (j+1)/nv));
        V.push(f(0, (j+1)/nv));
      }
      return V.flat();
    };
    // 圆柱侧面：U 沿周向(长边)，V 沿高度(短边)，保持贴图长边围绕圆周
    const tube = (n, r, h) => {
      const V=[]; for(let i=0;i<=n;i++){const th=2*Math.PI*i/n;const c=Math.cos(th),s=Math.sin(th);const u=i/n;
        V.push(r*c,r*s,-h/2, c,s,0, u,0); // 底部 v=0
        V.push(r*c,r*s, h/2, c,s,0, u,1); // 顶部 v=1
      } return V;
    };
    const disk = (n,r,z) => parametric((u,v)=>{
      const th=2*Math.PI*u; const c=Math.cos(th),s=Math.sin(th); const rr=r*v;
      return [rr*c, rr*s, z, 0,0, z>0?1:-1, u, v];
    }, n, 2);

    // 罐体尺寸与细节（参考 hw5 原版）：盖子微内凹、顶部小圆柱
    const radius = 0.25, height = 0.84, segments = 40;
    const capOffset = 0.03;
    const smallRadius = 0.1, smallHeight = 0.1;
    const smallCylinderZ = height/2 - capOffset;

    const canister = {
      side: { triangle_strip:true, data:new Float32Array(tube(segments, radius, height)) },
      top : { triangle_strip:true, data:new Float32Array(disk(segments, radius,  height/2 - capOffset)) },
      bot : { triangle_strip:true, data:new Float32Array(disk(segments, radius, -height/2 + capOffset)) },
      small: { triangle_strip:true, data:new Float32Array(tube(segments, smallRadius, smallHeight)) },
    };

    // 状态：progress 从 0 -> 1 控制暗盒显隐
    let texturesLoaded = false;
    let vertexMapSet = false;
    let progress = 0;
    let filmProgress = 0; // 底片拉出 0~1
    // 初始布局仅用于所有盒子在展示阶段的参考（已在顶部 boxPos 设置）

    // 双击：盒子态 -> 进入暗盒；暗盒态 -> 切换/收回 strip
    canvas.addEventListener('dblclick', () => {
      if (target > 0.5) {
        filmTarget = filmTarget > 0.5 ? 0 : 1;
      } else {
        target = 1;
        filmTarget = 0;
      }
    });

    const matrix = new Matrix();
    const lerp = (a,b,t)=>a+(b-a)*t;
    const lerpVec3=(a,b,t)=>[lerp(a[0],b[0],t), lerp(a[1],b[1],t), lerp(a[2],b[2],t)];

    const drawTex = (mesh, mat, samplerIdx, color=[1,1,1]) => {
      autodraw = false;
      const aspect = canvas.width / canvas.height;
      const m = mxm(perspective(0,0,-.6), mxm(scale(1/aspect,1,1), mat));
      setUniform('Matrix4fv','uMF',false,m);
      setUniform('Matrix4fv','uMI',false,inverse(m));
      setUniform('3fv','uColor',color);
      setUniform('1i','uUseTexture',1);
      if (textures[samplerIdx]) {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, textures[samplerIdx]);
        setUniform('1iv','uSampler',[0]); // 使用纹理单元0
      }
      drawMesh(mesh);
    };
    const drawSolid = (mesh, mat, color) => {
      autodraw = false;
      const aspect = canvas.width / canvas.height;
      const m = mxm(perspective(0,0,-.6), mxm(scale(1/aspect,1,1), mat));
      setUniform('Matrix4fv','uMF',false,m);
      setUniform('Matrix4fv','uMI',false,inverse(m));
      setUniform('3fv','uColor',color);
      setUniform('1i','uUseTexture',0);
      drawMesh(mesh);
    };

    this.update = () => {
      if (!vertexMapSet) { vertexMap(['aPos',3,'aNor',3,'aUV',2]); vertexMapSet = true; }
        if (!texturesLoaded) {
          boxTexturesA.forEach((src,i)=>addTexture(0+i,src));   // 盒子A
          boxTexturesB.forEach((src,i)=>addTexture(20+i,src));  // 盒子B
          boxTexturesC.forEach((src,i)=>addTexture(40+i,src));  // 盒子C
          addTexture(10,'textures/e100_can2.png'); // 暗盒纹理
          addTexture(11,'textures/cp200_can.jpg'); // 底片占位/齿孔纹理
          texturesLoaded = true;
        }

      // 平滑过渡
      const now = performance.now();
      const dt = (now - lastTick) / 1000;
      lastTick = now;
      if (autoSpin) spinAngle += dt * 0.3; // ~0.3 rad/s

      progress = lerp(progress, target, 0.12);
      filmProgress = lerp(filmProgress, filmTarget, 0.08);
      const spin = spinAngle;
      const boxVis = 1 - progress;
      const darkVis = progress;

      // 画纸盒：目标尺寸约 6*4*4，基于 unit cube(-1~1)缩放 (3,2,2)=6*4*4，并整体再缩小到场景合适大小
      const boxScale = 0.11; // 全局缩放系数，保持视觉大小（可微调）
      if (boxVis > 0.05) {
        const visScale = boxVis; // 渐隐时缩小
        // 三个盒子全部展示，按各自贴图与偏移
        const texGroups = [
          [0,1,2,3,4,5],
          [20,21,22,23,24,25],
          [40,41,42,43,44,45],
        ];
        for (let i = 0; i < 3; i++) {
          matrix.identity()
            .move(
              boxPos[i].pos[0] + boxPos[i].offset[0],
              boxPos[i].pos[1] + boxPos[i].offset[1],
              boxPos[i].pos[2] + boxPos[i].offset[2]
            )
            .turnX(boxPos[i].rot[0])
            .turnY(spin + boxPos[i].rot[1])
            .scale(2*boxScale*visScale, 3*boxScale*visScale, 2*boxScale*visScale);
          const t = texGroups[i];
          drawTex(cubeFaces.front, matrix.get(), t[0]);
          drawTex(cubeFaces.back , matrix.get(), t[1]);
          drawTex(cubeFaces.left , matrix.get(), t[2]);
          drawTex(cubeFaces.right, matrix.get(), t[3]);
          drawTex(cubeFaces.top  , matrix.get(), t[4]);
          drawTex(cubeFaces.bottom,matrix.get(), t[5]);
        }
      }

      // 画暗盒（由 progress 控制缩放出现）——仅选中盒
      if (darkVis > 0.05) {
        matrix.identity()
          // 与纸盒共享出现/消失位置
          .move(
            boxPos[activeBox].pos[0] + boxPos[activeBox].offset[0],
            boxPos[activeBox].pos[1] + boxPos[activeBox].offset[1],
            boxPos[activeBox].pos[2] + boxPos[activeBox].offset[2]
          )
          .turnX(boxPos[activeBox].rot[0])
          .turnY(-spin*1.2 + boxPos[activeBox].rot[1])
          .turnX(-Math.PI / 2) // 竖直且倒转，让小圆柱朝上
          .scale(darkVis*0.7, darkVis*0.7, darkVis*0.7);
        drawTex(canister.side, matrix.get(), 10, [1,1,1]);
        drawSolid(canister.top, matrix.get(), [0.15,0.15,0.15]);
        drawSolid(canister.bot, matrix.get(), [0.15,0.15,0.15]);
        matrix.push();
          matrix.move(0, 0, smallCylinderZ + smallHeight/2);
          drawSolid(canister.small, matrix.get(), [0.15,0.15,0.15]);
        matrix.pop();

        // 底片：简单长方形条，沿 X 方向从罐体侧壁开口生成
        if (filmProgress > 0.01) {
          const filmWidth = height * 1.3;   // 与罐体等高，可调
          const filmLen = height * 6;       // 长度，可调
          // 平面 2 三角
          const fw = filmWidth * 0.5;
          const fl = filmLen;
          const filmBias = 0.02;            // 偏移加大，降低穿模
          const filmMesh = {
            triangle_strip:false,
            data:new Float32Array([
              0, -fw, -filmBias, 0,0,1, 0,0,
              0,  fw, -filmBias, 0,0,1, 0,1,
              fl,  fw, -filmBias, 0,0,1, 1,1,
              fl,  fw, -filmBias, 0,0,1, 1,1,
              fl, -fw, -filmBias, 0,0,1, 1,0,
              0, -fw, -filmBias, 0,0,1, 0,0,
            ])
          };
          matrix.push();
            // 从开口生成：锚点在开口处，长度从 0 拉伸到目标
            matrix.move(-radius - filmBias, 0, 0);        // 贴在侧壁开口，略微外偏
            matrix.turnX(boxPos[activeBox].rot[0]).turnY(boxPos[activeBox].rot[1]).turnX(-Math.PI / 2);
            matrix.scale(filmProgress, 1, 1);             // 仅沿 X 拉伸，防穿模
            matrix.scale(0.7,0.7,0.7);                     // 匹配暗盒缩放
            // 绘制时关闭深度写入，减少与罐体的深度冲突
            gl.depthMask(false);
            drawTex(filmMesh, matrix.get(), 11, [1,1,1]);
            gl.depthMask(true);
          matrix.pop();
        }
      }
    };
  }

  gl_start(canvas, new Scene());
});
</script>
</body>